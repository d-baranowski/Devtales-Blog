{"title":"Effective Jackson with annotations in Spring Boot","slug":"effective-jackson-with-annotations-in-spring-boot","jsonRepresentation":"{\n  \"entityMap\": {\n    \"0\": {\n      \"type\": \"LINK\",\n      \"mutability\": \"MUTABLE\",\n      \"data\": {\n        \"url\": \"https://projectlombok.org/features/all\"\n      }\n    },\n    \"1\": {\n      \"type\": \"LINK\",\n      \"mutability\": \"MUTABLE\",\n      \"data\": {\n        \"url\": \"https://github.com/d-baranowski/jackson-tricks\"\n      }\n    }\n  },\n  \"blocks\": [\n    {\n      \"key\": \"2brnv\",\n      \"text\": \"Effective Jackson with annotations in Spring Boot\",\n      \"type\": \"header-two\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"8hrea\",\n      \"text\": \"With the current craze about micro-services I spend a considerable amount of time dealing with Rest API's. They mostly send and receive data in JSON format. That is where Jackson comes in handy. In this article I'll show some code examples of some non trivial use cases of Jackson I came across.\\n\",\n      \"type\": \"summary\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"2lo47\",\n      \"text\": \"Technology Versions:\",\n      \"type\": \"unstyled\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [\n        {\n          \"offset\": 0,\n          \"length\": 20,\n          \"style\": \"BOLD\"\n        }\n      ],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"5qlvs\",\n      \"text\": \"Java 8\",\n      \"type\": \"unordered-list-item\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"cbtn3\",\n      \"text\": \"Spring Boot: 1.5.7.Release\",\n      \"type\": \"unordered-list-item\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"fabv1\",\n      \"text\": \"Jackson: 2.8.10\",\n      \"type\": \"unordered-list-item\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"adh6v\",\n      \"text\": \"Lombok: I use lombok annotations check out their website if the code confuses you:  Thank me later ;)\\n\",\n      \"type\": \"unordered-list-item\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [],\n      \"entityRanges\": [\n        {\n          \"offset\": 43,\n          \"length\": 13,\n          \"key\": 0\n        }\n      ],\n      \"data\": {}\n    },\n    {\n      \"key\": \"f50n4\",\n      \"text\": \"I prefer using annotations instead of custom deserializers and manual json building because it reduces the amount of code I need  write which in turn makes my code easier to maintain and reduces the room for errors. \",\n      \"type\": \"unstyled\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"fcf0s\",\n      \"text\": \"Changing property name between serializing and deserializing\",\n      \"type\": \"header-two\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"elemj\",\n      \"text\": \"In API to API communication sometimes the Json I receive has errors or doesn't exactly match the output I need I can customise how properties of my Model are deserialized and serialized. This allows me to map Json objects in a single model without the need to create two separate models and mapping the manually. \\n\",\n      \"type\": \"unstyled\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"b5g5h\",\n      \"text\": \"// java //\\n//\\n// In this example we change how object is serialized and deserialized using only  \\n// annotations. Use of WRITE_ONLY allows to specify that this annotation only\\n// applies when deserializing from json. Using an annotation on a getter\\n// also signifies that it only applies when serializing.\\n\\n\\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\\nimport com.fasterxml.jackson.annotation.JsonProperty;\\nimport lombok.AllArgsConstructor;\\nimport lombok.Builder;\\nimport lombok.EqualsAndHashCode;\\nimport lombok.Getter;\\nimport lombok.NoArgsConstructor;\\n\\n@Builder()\\n@Getter()\\n@EqualsAndHashCode()\\n@JsonIgnoreProperties(ignoreUnknown = true)\\n@AllArgsConstructor()\\n@NoArgsConstructor()\\npublic class DeserializeSerializeDifferently {\\n   private Integer channelID;\\n   \\n   //Deserialize from json as 'code'\\n   @JsonProperty(access = JsonProperty.Access.WRITE_ONLY)\\n   private String code;\\n   \\n   //Deserialize from json as 'shortName'\\n   @JsonProperty(access = JsonProperty.Access.WRITE_ONLY)\\n   private String shortName;\\n   private Integer bitValue;\\n\\n   //Serialize to json as 'name'\\n   @JsonProperty(value = \\\"name\\\", access = JsonProperty.Access.READ_ONLY)\\n   public String getName() {\\n      return this.shortName;\\n   }\\n\\n   //Serialize to json as 'value'\\n   @JsonProperty(value = \\\"value\\\", access = JsonProperty.Access.READ_ONLY)\\n   public String getValue() {\\n      return this.code;\\n   }\\n}\",\n      \"type\": \"code-block\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [\n        {\n          \"offset\": 712,\n          \"length\": 31,\n          \"style\": \"UNDERLINE\"\n        },\n        {\n          \"offset\": 863,\n          \"length\": 10,\n          \"style\": \"ITALIC\"\n        },\n        {\n          \"offset\": 991,\n          \"length\": 10,\n          \"style\": \"ITALIC\"\n        },\n        {\n          \"offset\": 1157,\n          \"length\": 9,\n          \"style\": \"ITALIC\"\n        },\n        {\n          \"offset\": 1329,\n          \"length\": 9,\n          \"style\": \"ITALIC\"\n        }\n      ],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"981qb\",\n      \"text\": \"Easy Dates parsing and formatting\",\n      \"type\": \"header-two\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"9e0ql\",\n      \"text\": \"On many occasions the date format between the API talking to each other isn't matching. Jackson can help you abstract away the pain of having to parse the dates manually. \\n\",\n      \"type\": \"unstyled\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"e5v8r\",\n      \"text\": \"// java //\\n//\\n// Sometimes you need to map your dates into different formats.\\n// This setup allows doing this without any additional setup.\\n\\n@Builder()\\n@EqualsAndHashCode()\\n@JsonIgnoreProperties(ignoreUnknown = true)\\n@AllArgsConstructor()\\n@NoArgsConstructor()\\npublic class ParseDate {\\n   private static final SimpleDateFormat DESERIALIZE_PARSER =\\n      new SimpleDateFormat(\\\"EEE MMM d HH:mm:ss zzz yyyy\\\");\\n   private static final SimpleDateFormat SERIALIZE_FORMATTER =\\n      new SimpleDateFormat(\\\"yyyy-MM-dd\\\");\\n\\n   // Disable default parser\\n   @JsonIgnore()\\n   private Date date;\\n\\n   // Create custom deserializer\\n   @JsonProperty(access = JsonProperty.Access.WRITE_ONLY)\\n   public void setDate(String date) throws ParseException {\\n      this.date =  DESERIALIZE_PARSER.parse(date);\\n   }\\n\\n   // Disable default serializer\\n   @JsonIgnore\\n   public Date getDate() {\\n      return this.date;\\n   }\\n\\n   // Create custom serializer \\n   @JsonProperty(value = \\\"date\\\", access = JsonProperty.Access.READ_ONLY)\\n   public String getAsStringDate() {\\n      return SERIALIZE_FORMATTER.format(this.date);\\n   }\\n}\",\n      \"type\": \"code-block\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [\n        {\n          \"offset\": 273,\n          \"length\": 9,\n          \"style\": \"UNDERLINE\"\n        },\n        {\n          \"offset\": 357,\n          \"length\": 16,\n          \"style\": \"UNDERLINE\"\n        },\n        {\n          \"offset\": 479,\n          \"length\": 16,\n          \"style\": \"UNDERLINE\"\n        },\n        {\n          \"offset\": 326,\n          \"length\": 19,\n          \"style\": \"ITALIC\"\n        },\n        {\n          \"offset\": 447,\n          \"length\": 20,\n          \"style\": \"ITALIC\"\n        },\n        {\n          \"offset\": 660,\n          \"length\": 10,\n          \"style\": \"ITALIC\"\n        },\n        {\n          \"offset\": 751,\n          \"length\": 18,\n          \"style\": \"ITALIC\"\n        },\n        {\n          \"offset\": 988,\n          \"length\": 9,\n          \"style\": \"ITALIC\"\n        },\n        {\n          \"offset\": 1049,\n          \"length\": 19,\n          \"style\": \"ITALIC\"\n        }\n      ],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"3ln5m\",\n      \"text\": \"I hope you find these examples useful. For the full code with tests click here.\",\n      \"type\": \"unstyled\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [],\n      \"entityRanges\": [\n        {\n          \"offset\": 68,\n          \"length\": 10,\n          \"key\": 1\n        }\n      ],\n      \"data\": {}\n    }\n  ]\n}","summary":"With the current craze about micro-services I spend a considerable amount of time dealing with Rest API's. They mostly send and receive data in JSON format. That is where Jackson comes in handy. In this article I'll show some code examples of some non trivial use cases of Jackson I came across.\n"}