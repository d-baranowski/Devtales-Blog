{"title":"Private variables in JavaScript aka What are Closures!?","slug":"private-variables-in-javascript-aka-what-are-closures","jsonRepresentation":"{\n  \"entityMap\": {},\n  \"blocks\": [\n    {\n      \"key\": \"4g2ig\",\n      \"text\": \"Private variables in JavaScript aka What are Closures!?\",\n      \"type\": \"header-two\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [\n        {\n          \"offset\": 0,\n          \"length\": 55,\n          \"style\": \"BOLD\"\n        }\n      ],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"7f4q8\",\n      \"text\": \"There is a common misconception within the Java community that having private variables in JS is impossible. This isn't true. It simply requires a little more work than writing private in front of the variable name. \\n\",\n      \"type\": \"summary\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"5kpnt\",\n      \"text\": \"Scope in JavaScript\",\n      \"type\": \"header-two\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"3qrmi\",\n      \"text\": \"Unlike Java, in JavaScript variables aren't block scoped. We are used to writing code like this: \\n\",\n      \"type\": \"unstyled\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"dfoq9\",\n      \"text\": \"// java //\\npublic void doAThing(final boolean condition) {\\n   if (condition) {\\n      final String confirmation = \\\"I did the thing!\\\";\\n      System.out.println(confirmation);\\n   }\\n\\n\\n   final String confirmation = \\\"This is a different scope!\\\";\\n   System.out.println(confirmation);\\n}\",\n      \"type\": \"code-block\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"7pr1f\",\n      \"text\": \"Furthermore, anything defined in the parent scope will be available  in all its sub scopes like so: \\n\",\n      \"type\": \"unstyled\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"2240n\",\n      \"text\": \"// java //\\npublic void doAnotherThing(final boolean condition) {\\n   final String confirmationMessage = \\\"I %s the thing!\\\";\\n\\n   if (condition) {\\n      System.out.println(String.format(confirmationMessage, \\\"did\\\"))\\n   } else { \\n      System.out.println(String.format(confirmationMessage, \\\"did not do\\\"))\\n   }\\n}\",\n      \"type\": \"code-block\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"75oa2\",\n      \"text\": \"In JavaScript variables are function scoped! This means that any variable we declare in a function shares its scope with the rest of the variables in the same function and all functions declared within this scope. \\n\",\n      \"type\": \"unstyled\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [\n        {\n          \"offset\": 28,\n          \"length\": 15,\n          \"style\": \"BOLD\"\n        }\n      ],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"cjjsf\",\n      \"text\": \"// javascript //\\n\\nfunction doAThing(condition) {\\n   if (condition) {\\n      var confirmation = \\\"I did the thing!\\\";\\n      console.log(confirmation)\\n   }\\n\\n\\n   confirmation = \\\"This is the same scope and the same variable!\\\";\\n   console.log(confirmation)\\n}\\n\\nfunction doManyThings(n) {\\n   for (i = 0; i < n; i++) {\\n      console.log(i + \\\" exists inside the loop\\\");\\n   }\\n\\n   console.log(i + \\\" still exists outside the loop\\\");\\n\\n   var printI = function() {\\n      console.log(i);\\n   }\\n\\n   printI(); // Prints the variable since the function inherits scope from its parent.\\n}\\n\\n\",\n      \"type\": \"code-block\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"4adfl\",\n      \"text\": \"You can use this feature of JavaScript to control the scope of your variables in a way which limits the access to the variable from the \\\"outside\\\".\\n\",\n      \"type\": \"unstyled\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"5dbtt\",\n      \"text\": \"// javascript //\\n\\n\\nfunction constructACounterWithPrivateVariable() {\\n   var privateCounter = 0;\\n\\n   function add () { \\n      privateCounter++;\\n      return privateCounter;\\n   }\\n   \\n   return add;\\n}\\n\\nconsole.log(privateCounter); //undefined. We don't have access to it from the outside\\n\\nvar incrementCounter = constructACounterWithPrivateVariable(); \\n// incrementCounter now holds a function which has access to privateCounter variable\\n\\n\\nconsole.log(incrementCounter()); // 1\\nconsole.log(incrementCounter()); // 2\\nconsole.log(incrementCounter()); // 3\\n\\n\\nfunction objectWithGetterButNoSetter(value) {\\n   return {\\n      getValue: function () {return value;}\\n   };\\n}\\n\\n\\nvar myObject = objectWithGetterButNoSetter(\\\"My immutable string\\\");\\n\\n\\nconsole.log(myObject.getValue()); // My immutable string\",\n      \"type\": \"code-block\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [],\n      \"entityRanges\": [],\n      \"data\": {}\n    }\n  ]\n}","summary":"There is a common misconception within the Java community that having private variables in JS is impossible. This isn't true. It simply requires a little more work than writing private in front of the variable name. \n"}