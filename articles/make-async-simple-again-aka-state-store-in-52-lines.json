{"title":"Make async simple again! - aka state store in 52 lines","slug":"make-async-simple-again-aka-state-store-in-52-lines","jsonRepresentation":"{\n  \"entityMap\": {\n    \"0\": {\n      \"type\": \"LINK\",\n      \"mutability\": \"MUTABLE\",\n      \"data\": {\n        \"url\": \"https://github.com/d-baranowski/simpler-react-store\"\n      }\n    }\n  },\n  \"blocks\": [\n    {\n      \"key\": \"acsc1\",\n      \"text\": \"Make async simple again! - aka state store in 52 lines\",\n      \"type\": \"header-two\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"5cbrf\",\n      \"text\": \"Redux allows to share state between component and also it helps to separate state from the component which aids testing. Unfortunately it also adds unnecessary layers of complexity. In order to have asynchronous behaviour in Redux  you'll need to write a lot of code. \",\n      \"type\": \"unstyled\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"83kl1\",\n      \"text\": \"In a world where everything is asynchronous I've had enough of confusing middle-wares, numerous action creators and obscure yield operators. In this article I will demonstrate how simple async operations can become without Redux.\",\n      \"type\": \"summary\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"bvt6e\",\n      \"text\": \"\",\n      \"type\": \"summary\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"5rnpu\",\n      \"text\": \"Demo\",\n      \"type\": \"header-two\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"ddbg6\",\n      \"text\": \"I used create-react-app to generate a starting point for myself. Below you'll find a simple app using my own implementations of createStore and connect.\",\n      \"type\": \"unstyled\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"couib\",\n      \"text\": \"\",\n      \"type\": \"unstyled\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"dsqrf\",\n      \"text\": \"CatPicturesStore.js\",\n      \"type\": \"unstyled\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [\n        {\n          \"offset\": 0,\n          \"length\": 19,\n          \"style\": \"BOLD\"\n        }\n      ],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"ag4hf\",\n      \"text\": \"// javascript //\\n\\nimport createStore from './createStore';\\n\\nconst store = createStore({\\n   loading: false,\\n   title: \\\"Default Title\\\",\\n   kitten: \\\"\\\",\\n   error: \\\"\\\",\\n   fetchKitten: () => {\\n      store.loading = true;\\n      const promise = fetch('https://aws.random.cat/meow').then((response) => {\\n         return response.json();\\n      }).then((json) => {\\n         store.loading = false;\\n         store.kitten = json.file;\\n      });\\n\\n      promise.catch((error) => {\\n         store.loading = false;\\n         store.error = error;\\n      }\\n   }\\n});\\n\\nexport default store;\\n\",\n      \"type\": \"code-block\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [\n        {\n          \"offset\": 0,\n          \"length\": 16,\n          \"style\": \"BOLD\"\n        },\n        {\n          \"offset\": 18,\n          \"length\": 7,\n          \"style\": \"BOLD\"\n        },\n        {\n          \"offset\": 37,\n          \"length\": 5,\n          \"style\": \"BOLD\"\n        },\n        {\n          \"offset\": 60,\n          \"length\": 6,\n          \"style\": \"BOLD\"\n        },\n        {\n          \"offset\": 100,\n          \"length\": 5,\n          \"style\": \"BOLD\"\n        },\n        {\n          \"offset\": 209,\n          \"length\": 4,\n          \"style\": \"BOLD\"\n        },\n        {\n          \"offset\": 221,\n          \"length\": 6,\n          \"style\": \"BOLD\"\n        },\n        {\n          \"offset\": 304,\n          \"length\": 7,\n          \"style\": \"BOLD\"\n        },\n        {\n          \"offset\": 379,\n          \"length\": 5,\n          \"style\": \"BOLD\"\n        },\n        {\n          \"offset\": 490,\n          \"length\": 5,\n          \"style\": \"BOLD\"\n        },\n        {\n          \"offset\": 545,\n          \"length\": 15,\n          \"style\": \"BOLD\"\n        }\n      ],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"fm3dg\",\n      \"text\": \"Note how fetchKitten function modifies the store state directly. There is no more need for lengthy reducers or boilerplate action creators. \",\n      \"type\": \"unstyled\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"7mdbu\",\n      \"text\": \"Unlike redux I would avoid using a single GOD store for the entire state of the application. Instead I would create multiple stores and separate state depending on how it's used. This is possible because there is no more need for the Provider component at the root of my application. My stores are simple objects that can be exported and imported where needed. \",\n      \"type\": \"unstyled\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [\n        {\n          \"offset\": 234,\n          \"length\": 8,\n          \"style\": \"ITALIC\"\n        }\n      ],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"750bi\",\n      \"text\": \"\",\n      \"type\": \"unstyled\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"bcvtn\",\n      \"text\": \"App.js\",\n      \"type\": \"unstyled\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [\n        {\n          \"offset\": 0,\n          \"length\": 6,\n          \"style\": \"BOLD\"\n        }\n      ],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"8e3dd\",\n      \"text\": \"Below I'll demonstrate how to make use of the store in your components. \",\n      \"type\": \"unstyled\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"2oakq\",\n      \"text\": \"// javascript //\\nimport React from 'react';\\nimport store from './CatPicturesStore'\\nimport connect from './connect';\\n\\nconst onChange = (event) => {\\n  store.title = event.target.value\\n};\\n\\nconst ComponentOne = connect(store, ({title}) => (\\n   <div>\\n      <h2>Hello Form Component One</h2>\\n      <div>{title}</div>\\n      <input type=\\\"text\\\" value={title}\\n             onChange={onChange}\\n      />\\n   </div>\\n));\\n\\nconst ComponentTwo = connect(store, ({title}) => (\\n   <div>   \\n      <h2>Hello Form Component Two</h2>\\n      <div>{title}</div>\\n      <input type=\\\"text\\\" value={title} onChange={onChange}/>\\n   </div>\\n));\\n\\nconst ComponentThree = connect(store, ({fetchKitten}) => (\\n    <div>\\n      <h2>Hello Form Component Three</h2>\\n      <button onClick={fetchKitten}>Press for Kitten</button>\\n    </div>\\n));\\n\\nconst ComponentFour = connect(store, ({loading, kitten, error}) => (\\n    <div>\\n      <h2>Hello Form Component Four</h2>\\n      <img style={{width: 300}} src={kitten} />\\n      {loading && <div>Loading a kitten</div>}\\n      {error && <div>Omg there was an error {error}</div>}\\n    </div>\\n));\\n\\nconst App = () => (\\n    <div>\\n      <ComponentOne/>\\n      <ComponentTwo/>\\n      <ComponentThree/>\\n      <ComponentFour />\\n    </div>\\n);\\n\\nexport default App;\",\n      \"type\": \"code-block\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [\n        {\n          \"offset\": 0,\n          \"length\": 16,\n          \"style\": \"BOLD\"\n        },\n        {\n          \"offset\": 17,\n          \"length\": 7,\n          \"style\": \"BOLD\"\n        },\n        {\n          \"offset\": 30,\n          \"length\": 5,\n          \"style\": \"BOLD\"\n        },\n        {\n          \"offset\": 44,\n          \"length\": 7,\n          \"style\": \"BOLD\"\n        },\n        {\n          \"offset\": 57,\n          \"length\": 5,\n          \"style\": \"BOLD\"\n        },\n        {\n          \"offset\": 83,\n          \"length\": 7,\n          \"style\": \"BOLD\"\n        },\n        {\n          \"offset\": 98,\n          \"length\": 5,\n          \"style\": \"BOLD\"\n        },\n        {\n          \"offset\": 117,\n          \"length\": 6,\n          \"style\": \"BOLD\"\n        },\n        {\n          \"offset\": 186,\n          \"length\": 6,\n          \"style\": \"BOLD\"\n        },\n        {\n          \"offset\": 407,\n          \"length\": 6,\n          \"style\": \"BOLD\"\n        },\n        {\n          \"offset\": 611,\n          \"length\": 6,\n          \"style\": \"BOLD\"\n        },\n        {\n          \"offset\": 800,\n          \"length\": 6,\n          \"style\": \"BOLD\"\n        },\n        {\n          \"offset\": 1090,\n          \"length\": 6,\n          \"style\": \"BOLD\"\n        },\n        {\n          \"offset\": 1227,\n          \"length\": 15,\n          \"style\": \"BOLD\"\n        }\n      ],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"et41s\",\n      \"text\": \"Inside onChange you can see that all I need to do is assign a new value to store.title for all the changes to become propagated across all connected components. Similarly all subscribed components are notified whenever fetchKitten modifies loading, error and kitten properties of the store. No need for a dispatcher. \",\n      \"type\": \"unstyled\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"3ehr9\",\n      \"text\": \"\",\n      \"type\": \"unstyled\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"1k1bc\",\n      \"text\": \"How does it work?\",\n      \"type\": \"header-two\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [\n        {\n          \"offset\": 0,\n          \"length\": 17,\n          \"style\": \"BOLD\"\n        }\n      ],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"b907a\",\n      \"text\": \"I implemented this simple store using JS Proxy. Proxy allows to register a handler on object properties that gets invoked whenever someone sets new value to given property.\\ncreateStore.jsCreate store creates a new Proxy which is native in JS. Proxy then ensures to call notifySubscribers whenever any of the object properties gets changed. The store will have all of the properties passed via storeProps parameter and a additional property subscribe. Everyone who calls subscribe will be notified when notifySubscribers gets called. \",\n      \"type\": \"unstyled\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [\n        {\n          \"offset\": 173,\n          \"length\": 14,\n          \"style\": \"BOLD\"\n        }\n      ],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"2m1kg\",\n      \"text\": \"// javascript //\\nimport uuid from './uuid';\\n\\nconst createStore = (storeProps) => {\\n\\tconst subscribers = {};\\n\\tconst notifySubscribers = (newValue) => {\\n\\t\\tObject.values(subscribers).forEach(callback => callback(newValue))\\n\\t};\\n\\n\\tconst handler = {\\n\\t\\tset(target, prop, value) {\\n\\t\\t\\tif ((prop === 'subscribe')) {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\ttarget[prop] = value;\\n\\t\\t\\tnotifySubscribers(target);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t};\\n\\n\\n\\treturn new Proxy({\\n\\t\\tsubscribe: (callback) => {\\n\\t\\t\\tconst id = uuid();\\n\\t\\t\\tsubscribers[id] = callback;\\n\\t\\t\\treturn () => delete subscribers[id];\\n\\t\\t},\\n\\t\\t...storeProps\\n\\t}, handler);\\n};\\n\\nexport default createStore;\",\n      \"type\": \"code-block\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [\n        {\n          \"offset\": 0,\n          \"length\": 16,\n          \"style\": \"BOLD\"\n        },\n        {\n          \"offset\": 422,\n          \"length\": 5,\n          \"style\": \"UNDERLINE\"\n        }\n      ],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"ecca4\",\n      \"text\": \"All that is left to do is connect components to the store. \",\n      \"type\": \"unstyled\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"f91if\",\n      \"text\": \"\\nconnect.js\",\n      \"type\": \"unstyled\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [\n        {\n          \"offset\": 1,\n          \"length\": 10,\n          \"style\": \"BOLD\"\n        }\n      ],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"fi9tp\",\n      \"text\": \"Connect is a standard higher order component (HOC) which subscribes to the store with a callback which will call set state on the HOC. The HOC will then re-render whenever setState is called and pass the store value down to the component as props.\\n\",\n      \"type\": \"unstyled\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"dogbm\",\n      \"text\": \"// javascript //\\nimport React from 'react';\\n\\nfunction connect(store, WrappedComponent) {\\n\\treturn class extends React.Component {\\n\\t\\tstate = store;\\n\\t\\t\\n\\t\\tcomponentDidMount() {\\n\\t\\t\\tthis.unsubscribe = store.subscribe((newValue) => {\\n\\t\\t\\t\\tthis.setState(newValue)\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\tcomponentWillUnmount() {\\n\\t\\t\\tthis.unsubscribe();\\n\\t\\t}\\n\\t\\t\\n\\t\\trender() {\\n\\t\\t\\tconst joinedProps = {\\n\\t\\t\\t\\t...this.props,\\n\\t\\t\\t\\t...this.state\\n\\t\\t\\t};\\n\\t\\t\\treturn <WrappedComponent {\\n\\t\\t\\t\\t...joinedProps\\n\\t\\t\\t}\\n\\t\\t\\t/>;\\n\\t\\t}\\n\\t};\\n}\\n\\nexport default connect;\",\n      \"type\": \"code-block\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [\n        {\n          \"offset\": 103,\n          \"length\": 7,\n          \"style\": \"UNDERLINE\"\n        }\n      ],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"1qhmo\",\n      \"text\": \"Summary\",\n      \"type\": \"header-two\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [\n        {\n          \"offset\": 0,\n          \"length\": 7,\n          \"style\": \"BOLD\"\n        }\n      ],\n      \"entityRanges\": [],\n      \"data\": {}\n    },\n    {\n      \"key\": \"8iacs\",\n      \"text\": \"I hope you'll find this useful. I like this approach because it gives me the testability I enjoy when using Redux but without the cost of unnecessary boilerplate code and complexity. All the source code can be found here.\",\n      \"type\": \"unstyled\",\n      \"depth\": 0,\n      \"inlineStyleRanges\": [],\n      \"entityRanges\": [\n        {\n          \"offset\": 216,\n          \"length\": 5,\n          \"key\": 0\n        }\n      ],\n      \"data\": {}\n    }\n  ]\n}","summary":"In a world where everything is asynchronous I've had enough of confusing middle-wares, numerous action creators and obscure yield operators. In this article I will demonstrate how simple async operations can become without Redux."}